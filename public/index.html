<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Camera Video Stream</title>
  <base href="/">
  <!-- JSMpeg for RTSP/WebSocket streaming -->
  <script src="https://cdn.jsdelivr.net/npm/jsmpeg@0.2.0/jsmpeg.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 15px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      overflow: hidden;
    }
    
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      text-align: center;
    }
    
    .header h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
    }
    
    .header p {
      opacity: 0.9;
      font-size: 1.1em;
    }
    
    .video-section {
      background: #000;
      border-radius: 10px;
      overflow: hidden;
      position: relative;
      min-height: 500px;
      margin: 20px;
    }
    
    .video-container {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
      min-height: 600px;
      position: relative;
      overflow: hidden;
    }
    
    video, img {
      max-width: 100%;
      max-height: 100%;
      width: 100%;
      height: auto;
      object-fit: contain;
      display: block;
    }
    
    #video-container img {
      image-rendering: auto;
      will-change: contents;
      backface-visibility: hidden;
      transform: translateZ(0);
    }
    
    .controls-bar {
      padding: 15px 20px;
      background: rgba(0,0,0,0.8);
      color: white;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 15px;
    }
    
    .stream-info {
      display: flex;
      align-items: center;
      gap: 15px;
      flex-wrap: wrap;
    }
    
    .stream-mode {
      padding: 5px 15px;
      background: rgba(255,255,255,0.2);
      border-radius: 20px;
      font-size: 0.9em;
    }
    
    .control-buttons {
      display: flex;
      gap: 10px;
    }
    
    .btn {
      padding: 8px 20px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.9em;
      transition: background 0.3s;
    }
    
    .btn:hover {
      background: #5568d3;
    }
    
    .btn-secondary {
      background: #6c757d;
    }
    
    .btn-secondary:hover {
      background: #5a6268;
    }
    
    .loading {
      text-align: center;
      padding: 40px;
      color: #fff;
      font-size: 1.2em;
    }
    
    @media (max-width: 768px) {
      .controls-bar {
        flex-direction: column;
        align-items: stretch;
      }
      
      .control-buttons {
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üìπ Camera Video Stream</h1>
      <p>Camera IP: <span id="camera-ip">10.10.20.53</span> | Username: CUBE_BS</p>
    </div>
    
    <div class="video-section">
      <div class="video-container" id="video-container">
        <div class="loading">Loading video stream...</div>
      </div>
      <div class="controls-bar">
        <div class="stream-info">
          <span class="stream-mode" id="stream-mode">Mode: Loading...</span>
        </div>
        <div class="control-buttons">
          <button class="btn" id="snapshot-btn">üì∏ Snapshot</button>
          <button class="btn btn-secondary" id="refresh-btn">üîÑ Refresh</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const API_BASE = '/api/camera';

    // Initialize on page load
    window.addEventListener('DOMContentLoaded', () => {
      loadVideoStream();
      setupEventListeners();
      updateStreamModeDisplay();
      setInterval(updateStreamModeDisplay, 1000);
    });

    function setupEventListeners() {
      document.getElementById('snapshot-btn').addEventListener('click', takeSnapshot);

      // Cleanup on page unload
      window.addEventListener('beforeunload', () => {
        if (rtspPlayer) {
          rtspPlayer.destroy();
          rtspPlayer = null;
        }
        // Stop RTSP stream on server
        fetch(`${API_BASE}/stream/rtsp/stop`).catch(() => {});
      });
      document.getElementById('refresh-btn').addEventListener('click', loadVideoStream);
    }

    let currentStreamMode = 'snapshot';
    let streamImg = null;
    let rtspPlayer = null;

    // Load video stream - tries RTSP first, then MJPEG, then snapshot
    async function loadVideoStream() {
      const container = document.getElementById('video-container');
      container.innerHTML = '<div class="loading">Loading video stream...</div>';

      try {
        // Try RTSP stream first (best quality, real-time, low latency)
        try {
          await loadRTSPStream(container);
          currentStreamMode = 'rtsp';
          return;
        } catch (rtspError) {
          console.log('RTSP stream not available, trying MJPEG:', rtspError.message);
        }

        // Try MJPEG stream (better quality, real-time)
        try {
          await loadMJPEGStream(container);
          currentStreamMode = 'mjpeg';
          return;
        } catch (mjpegError) {
          console.log('MJPEG stream not available, falling back to snapshot:', mjpegError.message);
        }

        // Fallback to snapshot mode
        await loadSnapshotStream(container);
        currentStreamMode = 'snapshot';
        
      } catch (error) {
        container.innerHTML = `
          <div class="loading" style="color: #dc3545;">
            <p>‚ö†Ô∏è Error loading stream: ${error.message}</p>
            <p style="font-size: 0.9em; margin-top: 10px;">Trying snapshot mode...</p>
            <button onclick="loadVideoStream()" style="margin-top: 15px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">Retry</button>
          </div>
        `;
        console.error('Stream load error:', error);
      }
    }

    // Load RTSP stream via WebSocket (best quality, real-time)
    async function loadRTSPStream(container) {
      return new Promise(async (resolve, reject) => {
        try {
          // Start RTSP stream on server
          const startResponse = await fetch(`${API_BASE}/stream/rtsp/start`);
          const startData = await startResponse.json();
          
          if (!startData.success) {
            throw new Error(startData.error || 'Failed to start RTSP stream');
          }

          // Get WebSocket URL
          const wsUrlResponse = await fetch(`${API_BASE}/stream/rtsp/ws-url`);
          const wsUrlData = await wsUrlResponse.json();
          
          if (!wsUrlData.success) {
            throw new Error('Failed to get WebSocket URL');
          }

          const wsUrl = wsUrlData.wsUrl;
          console.log('Connecting to RTSP WebSocket:', wsUrl);

          // Create canvas for JSMpeg
          const canvas = document.createElement('canvas');
          canvas.id = 'rtsp-canvas';
          canvas.style.width = '100%';
          canvas.style.height = 'auto';
          canvas.style.maxWidth = '100%';
          canvas.style.maxHeight = '100%';
          canvas.style.display = 'block';
          canvas.style.margin = '0 auto';
          canvas.style.objectFit = 'contain';

          container.innerHTML = '';
          container.appendChild(canvas);

          // Wait a bit for WebSocket server to be ready
          await new Promise(resolve => setTimeout(resolve, 500));

          // Create JSMpeg player with optimized settings for smooth playback
          rtspPlayer = new JSMpeg.Player(wsUrl, {
            canvas: canvas,
            autoplay: true,
            audio: false,
            loop: false,
            preserveDrawingBuffer: true, // Preserve buffer for smoother rendering
            progressive: false,
            throttled: false, // Don't throttle - play at full speed
            chunkSize: 256 * 1024, // Smaller chunks (256KB) for smoother buffering
            videoBufferSize: 1024 * 1024, // Larger video buffer (1MB) for smoother playback
            audioBufferSize: 128 * 1024, // Audio buffer (not used but good to set)
            pauseWhenHidden: false, // Keep playing when tab is hidden
            disableGl: false, // Use WebGL if available for better performance
            enableWorker: true, // Use Web Worker for better performance
            decodeFirstFrame: true // Decode first frame immediately
          });

          // Wait for connection
          setTimeout(() => {
            if (rtspPlayer && rtspPlayer.source) {
              console.log('‚úì RTSP stream loaded via WebSocket');
              resolve();
            } else {
              reject(new Error('RTSP WebSocket connection failed'));
            }
          }, 2000);

        } catch (error) {
          console.error('RTSP stream error:', error);
          reject(error);
        }
      });
    }

    // Load MJPEG stream (better quality)
    async function loadMJPEGStream(container) {
      return new Promise((resolve, reject) => {
        const mjpegUrl = `${API_BASE}/stream/mjpeg?t=${Date.now()}`;
        const img = document.createElement('img');
        
        img.style.width = '100%';
        img.style.height = 'auto';
        img.style.display = 'block';
        img.style.margin = '0 auto';
        img.style.objectFit = 'contain';
        img.style.maxHeight = '100%';
        
        img.onload = () => {
          container.innerHTML = '';
          container.appendChild(img);
          streamImg = img;
          console.log('‚úì MJPEG stream loaded');
          resolve();
        };
        
        img.onerror = () => {
          reject(new Error('MJPEG stream failed to load'));
        };
        
        setTimeout(() => {
          if (!img.complete) {
            reject(new Error('MJPEG stream timeout'));
          }
        }, 5000);
        
        img.src = mjpegUrl;
      });
    }

    // Load snapshot stream - ULTRA SMOOTH Canvas-based rendering
    async function loadSnapshotStream(container) {
      // Clear any existing intervals
      if (window.streamInterval) {
        clearInterval(window.streamInterval);
      }
      if (window.streamAnimationFrame) {
        cancelAnimationFrame(window.streamAnimationFrame);
      }
      
      // Create canvas for ultra-smooth rendering (no flicker)
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d', { alpha: false });
      canvas.style.width = '100%';
      canvas.style.height = 'auto';
      canvas.style.display = 'block';
      canvas.style.margin = '0 auto';
      canvas.style.objectFit = 'contain';
      canvas.style.maxHeight = '100%';
      canvas.style.imageRendering = 'auto';
      
      container.innerHTML = '';
      container.appendChild(canvas);
      streamImg = canvas; // Store canvas reference
      
      // Image buffer for smooth transitions
      let currentImage = new Image();
      let imageQueue = [];
      let isFirstLoad = true;
      let frameCount = 0;
      
      // Set canvas size based on container
      function resizeCanvas() {
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        if (containerWidth > 0 && containerHeight > 0) {
          canvas.width = containerWidth;
          canvas.height = containerHeight;
        }
      }
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      
      // Draw image to canvas
      function drawImage(img) {
        if (!img || !img.complete || img.naturalWidth === 0) return;
        
        resizeCanvas();
        const canvasAspect = canvas.width / canvas.height;
        const imgAspect = img.naturalWidth / img.naturalHeight;
        
        let drawWidth, drawHeight, drawX, drawY;
        
        if (imgAspect > canvasAspect) {
          // Image is wider - fit to width
          drawWidth = canvas.width;
          drawHeight = canvas.width / imgAspect;
          drawX = 0;
          drawY = (canvas.height - drawHeight) / 2;
        } else {
          // Image is taller - fit to height
          drawHeight = canvas.height;
          drawWidth = canvas.height * imgAspect;
          drawX = (canvas.width - drawWidth) / 2;
          drawY = 0;
        }
        
        // Clear and draw
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
      }
      
      // Load next image
      function loadNextImage() {
        if (imageQueue.length > 1) return; // Keep queue tight to reduce latency
        
        const img = new Image();
        img.crossOrigin = 'anonymous';
        
        img.onload = () => {
          imageQueue.push(img);
          if (isFirstLoad) {
            currentImage = img;
            drawImage(currentImage);
            isFirstLoad = false;
            console.log('‚úì Snapshot stream loaded (50 FPS Canvas mode)');
          }
        };
        
        img.onerror = () => {
          console.warn('Image load error, retrying...');
          setTimeout(loadNextImage, 100);
        };
        
        // Use cache-busting
        img.src = `${API_BASE}/snapshot?t=${Date.now()}&r=${Math.random()}&f=${frameCount++}`;
      }
      
      // Start loading images
      loadNextImage();
      loadNextImage(); // Preload second image
      
      // Ultra-smooth update loop using requestAnimationFrame
      let lastFrameTime = performance.now();
      const targetFPS = 50; // 50 FPS for ultra-smooth video
      const frameInterval = 1000 / targetFPS; // ~20ms per frame
      
      function updateFrame() {
        const now = performance.now();
        const elapsed = now - lastFrameTime;
        
        if (elapsed >= frameInterval) {
          // Check if we have a new image ready
          if (imageQueue.length > 0) {
            currentImage = imageQueue.shift();
            drawImage(currentImage);
            // Preload next image while displaying current
            loadNextImage();
          } else if (currentImage && currentImage.complete) {
            // Keep drawing current image while waiting for next
            drawImage(currentImage);
            loadNextImage();
          }
          
          lastFrameTime = now - (elapsed % frameInterval);
        }
        
        window.streamAnimationFrame = requestAnimationFrame(updateFrame);
      }
      
      // Start the ultra-smooth animation loop
      window.streamAnimationFrame = requestAnimationFrame(updateFrame);
      
      // Backup interval for image loading (independent of rendering)
      window.streamInterval = setInterval(() => {
        if (imageQueue.length < 2) {
          loadNextImage();
        }
      }, 20); // Load new images every 20ms (50 FPS)
    }

    // Take snapshot
    async function takeSnapshot() {
      try {
        const response = await fetch(`${API_BASE}/snapshot?t=${Date.now()}`);
        if (response.ok) {
          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `camera-snapshot-${Date.now()}.jpg`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          window.URL.revokeObjectURL(url);
          console.log('‚úì Snapshot saved');
        } else {
          alert('Failed to take snapshot');
        }
      } catch (error) {
        console.error('Snapshot error:', error);
        alert('Error taking snapshot: ' + error.message);
      }
    }

    // Update stream mode display
    function updateStreamModeDisplay() {
      const modeElement = document.getElementById('stream-mode');
      if (modeElement) {
        let modeText = 'Unknown';
        if (currentStreamMode === 'rtsp') {
          modeText = 'RTSP (Real-time - Best Quality)';
        } else if (currentStreamMode === 'mjpeg') {
          modeText = 'MJPEG (Real-time)';
        } else {
          modeText = 'Snapshot (50 FPS - Ultra Smooth)';
        }
        modeElement.textContent = `Mode: ${modeText}`;
      }
    }
  </script>
</body>
</html>
